#!/usr/bin/env python

import os, sys, stat, errno, time, argparse, logging
import fuse
import dxpy

fuse.fuse_python_api = (0, 2)

class DXInode(object):
    DIR  = 'dir'
    FILE = 'file'
    LINK = 'link'

    def __init__(self, type, name, mode, uid, gid, ctime=None, mtime=None, size=0, dxid=None):
        print "New inode!", type, name, mode, uid, gid
        self.type = type
        self.name = name     # file name
        self.dev  = 0        # device ID (if special file)
        self.mode = mode     # protection and file-type
        self.uid  = uid      # user ID of owner
        self.gid  = gid      # group ID of owner
        self.size = size
        self.dxid = dxid

        self.now()

        # Extended Attributes
        self.xattr = {}

        # Data 
        if stat.S_ISDIR(mode):
            self.data = set()
        else:
            self.data = ''
        
        if ctime:
            self.ctime = ctime
        if mtime:
            self.mtime = mtime

        self._handler = None

    @property
    def handler(self):
        if self._handler is None:
            self._handler = dxpy.get_handler(self.dxid)
        return self._handler

    def now(self):
        self.atime = time.time()   # time of last access
        self.mtime = self.atime    # time of last modification
        self.ctime = self.atime    # time of last status change

    def stat(self):
        stat = fuse.Stat()
        stat.st_mode  = self.mode       # protection bits
        stat.st_ino   = 0               # inode number
        stat.st_dev   = self.dev        # device
        stat.st_nlink = 2               # number of hard links
        stat.st_uid   = self.uid        # user ID of owner
        stat.st_gid   = self.gid        # group ID of owner
        stat.st_size  = self.size       # size of file, in bytes
        stat.st_atime = self.atime      # time of most recent access
        stat.st_mtime = self.mtime      # time of most recent content modification
        stat.st_ctime = self.ctime      # platform dependent; time of most recent metadata change on Unix, or the time of creation on Windows
        return stat

    def child(self, path):
        match = None
        if self.type == DXInode.DIR:
            nodes = path.split('/')
            for child in self.data:
                if child.name == nodes[0]:
                    if len(nodes) > 1:
                        match = child.child('/'.join(nodes[1:]))
                    else:
                        match = child
        return match

    def read(self, offset, length):
        #stat.st_atime = time.now()
        if self.dxid and self.dxid.startswith('file'):
            self.handler.seek(offset)
            return self.handler.read(length)
        else:
            return self.data[offset:offset+length]

    def write(self, offset, data):
        if self.dxid and self.dxid.startswith('file'):
            # TODO: write seek
            self.handler.write(data)
        else:
            raise NotImplemented()

        self.now()
        return len(data)

    def truncate(self, length):
        print "Truncating", self.name
        self.data = self.data[0:length]
        self.now()


class DXFS(fuse.Fuse):
    def __init__(self, project_id, *args, **kwargs):
        fuse.Fuse.__init__(self, *args, **kwargs)

        self.uid = os.getuid()
        self.gid = os.getgid()
        self.project_id = project_id

    def fsinit(self):
        # initialize the root inode
        self.root = DXInode(DXInode.DIR, 'root', 0755 | stat.S_IFDIR, self.uid, self.gid)
        self.project = dxpy.DXProject(self.project_id)

        try:
            #print "Populating folders..."
            folders = self.project.describe(input_params={"folders": True})['folders']
            for path in folders:
                if path == '/':
                    continue
                self.mkdir(str(path), 0755 | stat.S_IFDIR, make_remote=False)

            #print "Populated", len(folders), "folders"
            #print "Populating data objects..."
            for i in dxpy.search.find_data_objects(project=dxpy.WORKSPACE_ID, describe=True):
                dataobject = i["describe"]
                dataobject["folder"] = str(dataobject["folder"])
                dataobject["name"] = str(dataobject["name"])
                print dataobject

                if dataobject["class"] == "applet" or (dataobject["class"] == "record" and "pipeline" in dataobject["types"]):
                    mode = 0755
                else:
                    mode = 0644

                path = os.path.join(dataobject["folder"], dataobject["name"])
                self.create(path, None, mode,
                            ctime=dataobject['created']/1000,
                            mtime=dataobject['modified']/1000,
                            size=dataobject.get('size', 0),
                            dxid=dataobject['id'])
        except Exception as e:
            #print "Exception while populating dxfs:", e
            raise

        # background threads need to be initialized here
        # this is where we will spawn our persistence thread

    # --- Metadata 
    def getattr(self, path):
        node = self._node(path)
        if not node:
            return -errno.ENOENT
        else:
            return node.stat()

    def chmod(self, path, mode):
        node = self._node(path)
        if not node:
            return -errno.ENOENT
        node.mode = mode

    def chown(self, path, uid, gid):
        node = self._node(path)
        if not node:
            return -errno.ENOENT
        node.uid = uid
        node.gid = gid

    def utime(self, path, times):
        node = self._node(path)
        if not node:
            return -errno.ENOENT
        node.ctime = node.mtime = times[0]

    # --- Namespace 
    def unlink(self, path):
        #print 'unlink path:%s' % path
        parent = self._parent(path)
        child  = self._node(path)

        if not (parent or child):
            return -errno.ENOENT

        #print "Removing", child.handler
        child.handler.remove()
        parent.data.remove(child)

    def rename(self, oldpath, newpath):
        #print 'rename oldpath:%s newpath:%s' % (oldpath, newpath)
        old_dirname, old_filename = os.path.split(oldpath)
        new_dirname, new_filename = os.path.split(newpath)
        old_parent = self._parent(oldpath)
        new_parent = self._parent(newpath)
        node       = self._node(oldpath) 

        if not (old_parent or new_parent or node):
            return -errno.ENOENT

        if not new_parent.type == DXInode.DIR:
            return -errno.ENOTDIR

        node.name = new_filename
        if node.type == DXInode.DIR:
            dxpy.DXHTTPRequest('/' + self.project_id + '/renameFolder', {"folder": oldpath, "newpath": newpath})
        else:
            if new_dirname != old_dirname:
                self.project.move(new_dirname, [node.handler.get_id()])
            node.handler.rename(new_filename)

        old_parent.data.remove(node)
        new_parent.data.add(node)

    # --- Links 
    def symlink(self, path, newpath):
        #print 'symlink path:%s newpath:%s' % (path, newpath)

        source_node = self._node(path)
        filename    = os.path.basename(newpath)
        parent      = self._parent(newpath)

        if not (parent or source_node):
            return -errno.ENOENT

        if not parent.type == DXInode.DIR:
            return -errno.ENOTDIR

        node = DXInode(DXInode.LINK, filename, 0644 | stat.S_IFLNK, self.uid, self.gid)
        node.data = path

        parent.data.add(node)

    def readlink(self, path):
        #print 'readlink path:%s' % path
        node = self._node(path)
        if not node:
            return -errno.ENOENT

        return node.data

    # --- Extra Attributes 
    def setxattr(self, path, name, value, flags):
        #print 'setxattr path:%s name:%s value:%s flags:%s' % (path, name, value, flags)
        node = self._node(path)
        if not node:
            return -errno.ENOENT

        if name == 'tag':
            node.handler.add_tags([value])
        elif name == 'property':
            prop_name, prop_value = value.split(":")
            node.handler.add_properties({prop_name: prop_value})
        elif name == 'state' and value == 'closed':
            print "closing", node
            node.handler.close(block=True)
            node.handler = dxpy.get_handler(node.handler.get_id())
        node.xattr[name] = value

    def getxattr(self, path, name, size):
        #print 'getxattr path:%s name:%s size:%s' % (path, name, size)
        node = self._node(path)
        if not node:
            return -errno.ENOENT

        value = str(node.handler.describe().get(name, ''))

        if size == 0:   # We are asked for size of the value
            return len(value)

        return value

    def listxattr(self, path, size):
        #print 'listxattr path:%s size:%s' % (path, size)
        node = self._node(path)
        if not node:
            return -errno.ENOENT

        attrs = [str(attr) for attr in node.handler.describe().keys()]
        if size == 0:
            return len(attrs) + len(''.join(attrs))
        return attrs

    def removexattr(self, path, name):
        #print 'removexattr path:%s name:%s' % (path, name)
        node = self._node(path)
        if not node:
            return -errno.ENOENT

        if name in node.xattr:
            del node.xattr[name]

    # --- Files 
    # this appears to be the fallback if create fails
    def mknod(self, path, mode, dev):
        print 'mknod path:%s mode:%s dev:%s' % (path, mode, dev)

        filename    = os.path.basename(path)
        parent      = self._node(path)

        if not parent:
            return -errno.ENOENT

        if not parent.type == DXInode.DIR:
            return -errno.ENOTDIR

        node = DXInode(DXInode.FILE, filename, mode, self.uid, self.gid)
        node.dev = dev
        parent.data.add(node)        

    def create(self, path, flags, mode, ctime=None, mtime=None, size=0, dxid=None):
        print 'create path:%s flags:%s mode:%s' % (path, flags, mode)

        dirname, filename = os.path.split(path)
        parent = self._parent(path)

        if not parent:
            print "No parent!"
            return -errno.ENOENT

        if not parent.type == DXInode.DIR:
            print "Parent is not a dir!"
            return -errno.ENOTDIR

        if dxid is None:
            f = dxpy.new_dxfile(name=filename, folder=dirname)
            dxid = f.get_id()
        node = DXInode(DXInode.FILE, filename, mode | stat.S_IFREG, self.uid, self.gid, ctime=ctime, mtime=mtime, size=size, dxid=dxid)
        print "Adding file", node.name, "to", parent.name
        parent.data.add(node)
        #print "Parent contents:", parent.data

    def truncate(self, path, len):
        print 'truncate path:%s len:%s' % (path, len)

        node = self._node(path)

        if not node:
            return -errno.ENOENT

        node.truncate(len)

    def read(self, path, size, offset):
        print 'truncate path:%s size:%s offset:%s' % (path, size, offset)

        node = self._node(path)

        if not node:
            return -errno.ENOENT

        return node.read(offset, size)

    def write(self, path, buf, offset):
        print 'write path:%s buf:%s offset:%s' % (path, buf, offset)

        node = self._node(path)

        if not node:
            return -errno.ENOENT

        return node.write(offset, buf)

    # --- Directories 
    def mkdir(self, path, mode, make_remote=True):
        print 'mkdir path:%s mode:%s' % (path, mode)

        dirname, filename = os.path.split(path)
        parent = self._parent(path)

        if not parent:
            return -errno.ENOENT

        if not parent.type == DXInode.DIR:
            return -errno.ENOTDIR

        if make_remote:
            self.project.new_folder(path)

        node = DXInode(DXInode.DIR, filename, mode | stat.S_IFDIR, self.uid, self.gid)
        print "Adding dir", node.name, "to", parent.name
        parent.data.add(node)
        print "Parent contents:", parent.data

    def rmdir(self, path):
        print 'rmdir path:%s' % path

        parent      = self._parent(path)
        node        = self._node(path)

        if not (parent or node):
            return -errno.ENOENT

        if not node.type == DXInode.DIR:
            return -errno.ENOTDIR

        self.project.remove_folder(path)
        parent.data.remove(node)

    def readdir(self, path, offset):
        print 'readdir path:%s offset:%s' % (path, offset)

        node = self._node(path)
        print "reading dir", node.name, len(node.data), "entries"

        for meta in ['.', '..']:
            print "yielding", meta
            yield fuse.Direntry(meta)
        for child in node.data:
            print "yielding", child.name
            yield fuse.Direntry(child.name)


    # fixme
    def _readdir(self, path, offset):
        print 'readdir path:%s offset:%s' % (path, offset)

        node = self._node(path)
        if node is None:
            return

        print "reading dir", node.name, len(node.data), "entries"

        try:
            if node.type == DXInode.DIR:
                print "reading dir", node.name, len(node.data), "entries"
                i = -1
                for meta in ['.', '..']:
                    i += 1
                    if i < offset:
                        continue
                    print "yielding", meta, i
                    yield fuse.Direntry(meta, offset=i)
                for child in node.data:
                    i += 1
                    if i < offset:
                        continue
                    print "yielding", child.name, i
                    yield fuse.Direntry(child.name, offset=i, type=child.type)
            else:
                print "Not a dir - yielding", node.name
                yield fuse.Direntry(node.name)
        except Exception as e:
            print "EXCEPTION", e

    # --- Tree Helpers
    def _node(self, path):
        if path == '/':
            return self.root
        else:
            return self.root.child(path[1:])

    def _parent(self, path):
        parent_path = os.path.dirname(path)
        return self._node(parent_path)

parser = argparse.ArgumentParser(description="DNAnexus FUSE driver")
parser.add_argument("mountpoint", help="Directory to mount the filesystem on")
parser.add_argument("project_id", help="DNAnexus project ID to mount", default=dxpy.WORKSPACE_ID, nargs='?')
args = parser.parse_args()

if '_DX_DEBUG' in os.environ:
    # redirect stdout to a log (unbuffered)
    sys.stdout = open('dxfs.log', 'a', 0)
    sys.stderr = open('dxfs.err.log', 'a', 0)
else:
    sys.stdout = open(os.devnull, 'w')
    sys.stderr = open(os.devnull, 'w')

server = DXFS(project_id=args.project_id)
server.parse([args.mountpoint])
server.main()
